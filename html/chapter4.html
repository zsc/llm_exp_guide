<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第四章：纯语言任务实验设计</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">LLM 后训练实验设计指南</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第一章：后训练基础理论</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第二章：实验代码基础设施</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第三章：数据工程</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第四章：纯语言任务实验设计</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第五章：多模态任务实验设计</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第六章：强化学习与人类反馈</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第七章：训练循环与迭代优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第八章：评估与基准测试</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第九章：生产部署与监控</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第十章：案例研究与最佳实践</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="_1">第四章：纯语言任务实验设计</h1>
<h2 id="_2">章节概览</h2>
<p>本章深入探讨纯语言任务的后训练实验设计方法。我们将系统性地介绍如何针对不同类型的文本任务设计实验，包括多轮对话、长文本处理、推理链训练等核心场景。重点关注实验设计的方法论、评估指标选择、数据构造策略以及常见问题的解决方案。通过本章学习，您将掌握设计和执行高质量语言任务实验的完整流程。</p>
<h2 id="41">4.1 多轮对话的意图识别与状态管理</h2>
<p>多轮对话是 LLM 后训练中最具挑战性的任务之一。与单轮问答不同，多轮对话需要模型维护复杂的上下文状态、理解隐含意图、处理指代消解，并在保持连贯性的同时适应话题转换。本节将深入探讨如何设计实验来优化这些能力。</p>
<h3 id="411">4.1.1 多轮对话的核心挑战</h3>
<p>多轮对话系统面临的主要技术挑战包括：</p>
<ol>
<li><strong>上下文依赖性建模</strong></li>
</ol>
<p>多轮对话中，用户的每个输入都可能依赖于之前的对话历史。模型需要准确理解这种依赖关系：</p>
<div class="codehilite"><pre><span></span><code>用户：帮我分析这份报告的数据
助手：<span class="p">[</span>提供分析<span class="p">]</span>
用户：第三部分有什么问题吗？<span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span>需要理解<span class="s">&quot;第三部分&quot;</span>指代报告的第三部分
</code></pre></div>

<p>实验设计时需要考虑：</p>
<ul>
<li><strong>显式依赖</strong> vs <strong>隐式依赖</strong>：显式依赖通过代词、指示词体现；隐式依赖需要推理</li>
<li><strong>依赖距离</strong>：依赖的轮次跨度影响模型的记忆负担</li>
<li><strong>依赖类型</strong>：实体指代、事件指代、属性继承等</li>
</ul>
<ol start="2">
<li><strong>意图演化与切换</strong></li>
</ol>
<p>用户意图在对话过程中会发生演化或突然切换：</p>
<div class="codehilite"><pre><span></span><code>轮次 1-3：讨论技术问题（意图：技术咨询）
轮次 4：突然询问天气（意图切换：日常闲聊）
轮次 5：回到技术讨论（意图恢复：技术咨询）
</code></pre></div>

<p>关键实验指标：</p>
<ul>
<li>意图切换检测准确率</li>
<li>意图恢复后的上下文保持能力</li>
<li>多意图并存时的优先级处理</li>
</ul>
<ol start="3">
<li><strong>对话状态的累积效应</strong></li>
</ol>
<p>随着对话轮次增加，状态管理的复杂度呈指数增长：</p>
<div class="codehilite"><pre><span></span><code>状态空间大小 ≈ O(|S|^n)
其中 |S| 是单轮状态空间，n 是对话轮次
</code></pre></div>

<p>这导致：</p>
<ul>
<li><strong>状态爆炸</strong>：需要设计高效的状态压缩机制</li>
<li><strong>信息衰减</strong>：早期轮次的信息逐渐被遗忘</li>
<li><strong>噪声累积</strong>：错误理解在后续轮次中被放大</li>
</ul>
<h3 id="412">4.1.2 意图识别的实验设计</h3>
<p><strong>实验框架设计</strong></p>
<p>构建多轮意图识别实验需要系统性的方法：</p>
<div class="codehilite"><pre><span></span><code>┌─────────────┐     ┌──────────────┐     ┌───────────┐
│  对话历史   │────&gt;│  特征提取    │────&gt;│ 意图分类  │
│  H_1...H_t  │     │  &amp; 编码器    │     │   模型    │
└─────────────┘     └──────────────┘     └───────────┘
       │                    │                   │
       v                    v                   v
┌─────────────┐     ┌──────────────┐     ┌───────────┐
│ 当前输入 U_t│     │ 上下文融合   │     │ 意图 I_t  │
└─────────────┘     └──────────────┘     └───────────┘
</code></pre></div>

<p><strong>数据构造策略</strong></p>
<ol>
<li>
<p><strong>意图标注体系设计</strong>
   - 层次化意图树：主意图 -&gt; 子意图 -&gt; 细粒度意图
   - 意图转移矩阵：P(I_t | I_{t-1}, U_t)
   - 复合意图处理：多标签 vs 主导意图</p>
</li>
<li>
<p><strong>训练数据增强</strong></p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># 伪代码：对话数据增强</span>
<span class="k">def</span> <span class="nf">augment_dialogue</span><span class="p">(</span><span class="n">dialogue</span><span class="p">):</span>
    <span class="c1"># 1. 意图插入：在对话中插入无关意图</span>
    <span class="c1"># 2. 意图省略：删除部分显式意图表达</span>
    <span class="c1"># 3. 语言变换：同义改写保持意图不变</span>
    <span class="c1"># 4. 顺序打乱：测试鲁棒性</span>
    <span class="k">return</span> <span class="n">augmented_samples</span>
</code></pre></div>

<ol start="3">
<li><strong>困难样本挖掘</strong>
   - 意图边界模糊的对话
   - 快速意图切换序列
   - 长距离意图依赖</li>
</ol>
<p><strong>评估指标设计</strong></p>
<p>标准准确率不足以评估多轮意图识别，需要设计专门指标：</p>
<ol>
<li>
<p><strong>轮次感知准确率（Turn-Aware Accuracy）</strong>
   $$TAA = \sum_{t=1}^{T} w_t \cdot \mathbb{1}[pred_t = true_t]$$
其中 $w_t$ 是轮次权重，可以设计为递增（后期轮次更重要）或递减（早期理解更关键）</p>
</li>
<li>
<p><strong>意图切换 F1（Intent Switch F1）</strong>
   专门评估模型检测意图切换点的能力</p>
</li>
<li>
<p><strong>意图一致性得分（Intent Coherence Score）</strong>
$$ICS = \frac{1}{T-1} \sum_{t=2}^{T} sim(I_t, I_{t-1}) \cdot \mathbb{1}[switch_t = 0]$$</p>
</li>
</ol>
<h3 id="413">4.1.3 对话状态追踪</h3>
<p><strong>状态表示学习</strong></p>
<p>对话状态不仅包含显式信息（实体、属性），还包含隐式知识（用户偏好、情感状态）：</p>
<div class="codehilite"><pre><span></span><code>State_t = {
    &quot;entities&quot;: {实体及其属性},
    &quot;relations&quot;: {实体间关系},
    &quot;user_profile&quot;: {推断的用户信息},
    &quot;discourse&quot;: {对话结构信息},
    &quot;intent_history&quot;: {意图演化轨迹}
}
</code></pre></div>

<p><strong>状态更新机制</strong></p>
<ol>
<li><strong>覆盖更新（Overwrite）</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="nl">新信息与旧信息冲突</span><span class="p">:</span>
<span class="w">    </span><span class="k">State</span><span class="o">[</span><span class="n">key</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_value</span>
</code></pre></div>

<ol start="2">
<li><strong>累积更新（Accumulate）</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">State</span><span class="o">[</span><span class="n">key</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">merge</span><span class="p">(</span><span class="k">State</span><span class="o">[</span><span class="n">key</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">new_value</span><span class="p">)</span>
</code></pre></div>

<ol start="3">
<li><strong>条件更新（Conditional）</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="n">confidence</span><span class="p">(</span><span class="n">new_value</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nl">threshold</span><span class="p">:</span>
<span class="w">    </span><span class="k">State</span><span class="o">[</span><span class="n">key</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">weighted_avg</span><span class="p">(</span><span class="k">State</span><span class="o">[</span><span class="n">key</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">new_value</span><span class="p">)</span>
</code></pre></div>

<p><strong>实验设计要点</strong></p>
<ol>
<li>
<p><strong>状态槽位定义</strong>
   - 预定义槽位：适用于垂直领域
   - 开放槽位：适用于通用对话
   - 混合方案：核心槽位预定义 + 动态扩展</p>
</li>
<li>
<p><strong>状态初始化策略</strong>
   - 零初始化：从空状态开始
   - 先验初始化：基于用户画像或领域知识
   - 迁移初始化：从相似对话学习初始状态</p>
</li>
<li>
<p><strong>状态压缩与遗忘</strong></p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compress_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">max_size</span><span class="p">):</span>
    <span class="c1"># 信息论方法：保留高信息量状态</span>
    <span class="c1"># 注意力方法：保留高注意力权重状态</span>
    <span class="c1"># 时间衰减：指数衰减旧状态权重</span>
    <span class="k">return</span> <span class="n">compressed_state</span>
</code></pre></div>

<h3 id="414">4.1.4 上下文窗口管理策略</h3>
<p><strong>固定窗口 vs 动态窗口</strong></p>
<ol>
<li>
<p><strong>固定窗口策略</strong>
   - 优点：实现简单，计算开销可控
   - 缺点：可能截断重要信息
   - 适用场景：轮次较少的任务导向对话</p>
</li>
<li>
<p><strong>动态窗口策略</strong>
   - 基于信息密度调整：信息密集处扩大窗口
   - 基于意图边界调整：意图切换时重置窗口
   - 基于计算资源调整：自适应GPU内存</p>
</li>
</ol>
<p><strong>窗口内容选择</strong></p>
<p>不是所有历史信息都同等重要，需要设计选择机制：</p>
<div class="codehilite"><pre><span></span><code>重要性得分 = α <span class="gs">* 时间因子 + β *</span> 相关性因子 + γ <span class="gs">* 信息量因子</span>

<span class="gs">时间因子 = exp(-λ *</span> (t_current - t_utterance))
相关性因子 = cosine_sim(embedding_current, embedding_historical)
信息量因子 = -log(P(utterance | context))
</code></pre></div>

<p><strong>压缩技术</strong></p>
<ol>
<li><strong>摘要压缩</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="err">原始对话（</span><span class="mi">10</span><span class="err">轮）</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">摘要（</span><span class="mi">2</span><span class="o">-</span><span class="mi">3</span><span class="err">句）</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">保留关键信息</span>
</code></pre></div>

<ol start="2">
<li><strong>关键词提取</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>每轮提取 top-k 关键词，构建稀疏表示
</code></pre></div>

<ol start="3">
<li><strong>层次化压缩</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>近期轮次：完整保留
中期轮次：保留主要内容
远期轮次：仅保留意图和关键实体
</code></pre></div>

<p><strong>实验优化策略</strong></p>
<ol>
<li><strong>渐进式训练</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_epochs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">epoch</span> <span class="o">&lt;</span> <span class="n">warmup_epochs</span><span class="p">:</span>
        <span class="n">max_context_length</span> <span class="o">=</span> <span class="n">min_length</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_context_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="n">min_length</span> <span class="o">+</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">-</span> <span class="n">warmup_epochs</span><span class="p">)</span> <span class="o">*</span> <span class="n">increment</span><span class="p">,</span>
            <span class="n">max_length</span>
        <span class="p">)</span>
    <span class="n">train_with_context_length</span><span class="p">(</span><span class="n">max_context_length</span><span class="p">)</span>
</code></pre></div>

<ol start="2">
<li>
<p><strong>课程学习</strong>
   - 从短对话到长对话
   - 从单意图到多意图
   - 从简单依赖到复杂依赖</p>
</li>
<li>
<p><strong>注意力模式分析</strong>
   定期可视化注意力矩阵，识别：</p>
</li>
</ol>
<ul>
<li>位置偏差（过度关注近期或远期）</li>
<li>模式坍塌（注意力过度集中）</li>
<li>梯度消失（深层注意力失效）</li>
</ul>
<h2 id="42">4.2 长文本处理与位置编码优化</h2>
<p>长文本处理是 LLM 后训练中的关键技术挑战。随着应用场景从简单问答扩展到文档理解、代码生成、长篇创作等领域，模型需要处理数万甚至数十万 token 的输入。本节探讨如何通过实验设计克服长序列建模的技术瓶颈。</p>
<h3 id="421">4.2.1 长序列建模的技术瓶颈</h3>
<p><strong>计算复杂度问题</strong></p>
<p>标准 Transformer 的自注意力机制具有 O(n²) 的时间和空间复杂度：</p>
<div class="codehilite"><pre><span></span><code>内存需求 = batch_size × seq_len² × hidden_dim × 4 bytes
计算需求 = 2 × batch_size × seq_len² × hidden_dim FLOPs

例：seq_len=32K, hidden_dim=4096, batch_size=1
内存 ≈ 16GB (仅注意力矩阵)
</code></pre></div>

<p>这导致：</p>
<ul>
<li><strong>内存墙</strong>：GPU内存限制了最大序列长度</li>
<li><strong>计算墙</strong>：训练时间随序列长度平方增长</li>
<li><strong>梯度消失</strong>：深层网络中的长距离依赖难以学习</li>
</ul>
<p><strong>位置编码的局限性</strong></p>
<ol>
<li><strong>绝对位置编码的外推失败</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>训练：position ∈ [0, 2048]
推理：position = 10000
结果：性能急剧下降
</code></pre></div>

<ol start="2">
<li><strong>相对位置编码的计算开销</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>相对位置矩阵：O(n² × d_k)
每个注意力头都需要独立计算
</code></pre></div>

<ol start="3">
<li><strong>位置信息的语义混淆</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>&quot;第1000个token&quot; 在不同文档中含义不同
需要考虑：段落边界、句子边界、语义单元
</code></pre></div>

<p><strong>信息瓶颈与遗忘曲线</strong></p>
<p>长序列中的信息传递存在瓶颈：</p>
<div class="codehilite"><pre><span></span><code>信息保留率 ≈ exp(-λ × distance)
其中 λ 是遗忘系数，distance 是 token 距离
</code></pre></div>

<p>实验观察：</p>
<ul>
<li>2K tokens：95% 信息保留</li>
<li>8K tokens：70% 信息保留  </li>
<li>32K tokens：&lt;40% 信息保留</li>
</ul>
<h3 id="422">4.2.2 位置编码的改进方法</h3>
<p><strong>RoPE（旋转位置编码）优化</strong></p>
<p>RoPE 通过旋转矩阵编码相对位置，具有良好的外推性：</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">rope_encoding</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
    <span class="c1"># 基础 RoPE</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mf">10000.0</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># 位置频率计算</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">theta</span> <span class="o">**</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span> <span class="o">/</span> <span class="n">dim</span><span class="p">))</span>

    <span class="c1"># 应用旋转</span>
    <span class="n">q_rot</span> <span class="o">=</span> <span class="n">apply_rotation</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span>
    <span class="n">k_rot</span> <span class="o">=</span> <span class="n">apply_rotation</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">q_rot</span><span class="p">,</span> <span class="n">k_rot</span>
</code></pre></div>

<p><strong>实验优化策略</strong>：</p>
<ol>
<li><strong>动态 theta 调整</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># 根据序列长度自适应调整</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">base_theta</span> <span class="o">*</span> <span class="p">(</span><span class="n">current_len</span> <span class="o">/</span> <span class="n">base_len</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
</code></pre></div>

<ol start="2">
<li><strong>NTK-aware 缩放</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># Neural Tangent Kernel 感知的位置缩放</span>
<span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">/</span> <span class="n">base_len</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">dim</span> <span class="o">/</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span> <span class="o">/</span> <span class="n">scale</span>
</code></pre></div>

<ol start="3">
<li><strong>位置插值（Position Interpolation）</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># 线性插值压缩位置范围</span>
<span class="n">compressed_pos</span> <span class="o">=</span> <span class="n">positions</span> <span class="o">*</span> <span class="p">(</span><span class="n">base_len</span> <span class="o">/</span> <span class="n">current_len</span><span class="p">)</span>
</code></pre></div>

<p><strong>ALiBi（Attention with Linear Biases）</strong></p>
<p>ALiBi 通过线性偏置实现位置感知，无需显式位置编码：</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">alibi_bias</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">):</span>
    <span class="c1"># 为每个注意力头生成不同的斜率</span>
    <span class="n">slopes</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">8</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_heads</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_heads</span><span class="p">)</span>

    <span class="c1"># 构建偏置矩阵</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">seq_len</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">seq_len</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">biases</span> <span class="o">=</span> <span class="n">slopes</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">positions</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">biases</span>
</code></pre></div>

<p><strong>实验对比框架</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compare_position_encodings</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">test_lengths</span><span class="p">):</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">encoding_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rope&#39;</span><span class="p">,</span> <span class="s1">&#39;alibi&#39;</span><span class="p">,</span> <span class="s1">&#39;absolute&#39;</span><span class="p">,</span> <span class="s1">&#39;relative&#39;</span><span class="p">]:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">set_position_encoding</span><span class="p">(</span><span class="n">encoding_type</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="n">test_lengths</span><span class="p">:</span>
            <span class="c1"># 测试困惑度</span>
            <span class="n">ppl</span> <span class="o">=</span> <span class="n">evaluate_perplexity</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>

            <span class="c1"># 测试长距离依赖</span>
            <span class="n">long_dep_score</span> <span class="o">=</span> <span class="n">test_long_range_dependency</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>

            <span class="c1"># 测试位置敏感任务</span>
            <span class="n">position_acc</span> <span class="o">=</span> <span class="n">test_position_sensitive_tasks</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>

            <span class="n">results</span><span class="p">[</span><span class="n">encoding_type</span><span class="p">][</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;perplexity&#39;</span><span class="p">:</span> <span class="n">ppl</span><span class="p">,</span>
                <span class="s1">&#39;long_dependency&#39;</span><span class="p">:</span> <span class="n">long_dep_score</span><span class="p">,</span>
                <span class="s1">&#39;position_accuracy&#39;</span><span class="p">:</span> <span class="n">position_acc</span>
            <span class="p">}</span>

    <span class="k">return</span> <span class="n">results</span>
</code></pre></div>

<h3 id="423">4.2.3 注意力机制的优化</h3>
<p><strong>稀疏注意力模式</strong></p>
<ol>
<li><strong>局部注意力（Local Attention）</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>每个 token 只关注窗口内的 k 个邻近 token
复杂度：O(n × k) where k &lt;&lt; n
</code></pre></div>

<ol start="2">
<li><strong>跨步注意力（Strided Attention）</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>固定步长采样：attend to every k-th token
复杂度：O(n²/k)
</code></pre></div>

<ol start="3">
<li><strong>Longformer 风格的混合注意力</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">Global</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">Local</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Dilated</span><span class="w"> </span><span class="n">patterns</span>
<span class="n">全局</span><span class="w"> </span><span class="n">token</span><span class="err">：</span><span class="o">[</span><span class="n">CLS</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">SEP</span><span class="o">]</span><span class="w"> </span><span class="n">等特殊标记</span>
<span class="n">局部窗口</span><span class="err">：</span><span class="k">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">512</span>
<span class="n">膨胀窗口</span><span class="err">：</span><span class="n">dilation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span>
</code></pre></div>

<p><strong>Flash Attention 优化</strong></p>
<p>Flash Attention 通过 IO 优化显著提升长序列性能：</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">flash_attention_experiment</span><span class="p">(</span><span class="n">seq_lengths</span><span class="p">,</span> <span class="n">batch_sizes</span><span class="p">):</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">seq_len</span> <span class="ow">in</span> <span class="n">seq_lengths</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">batch_size</span> <span class="ow">in</span> <span class="n">batch_sizes</span><span class="p">:</span>
            <span class="c1"># 标准注意力</span>
            <span class="n">std_time</span><span class="p">,</span> <span class="n">std_mem</span> <span class="o">=</span> <span class="n">benchmark_standard_attention</span><span class="p">(</span>
                <span class="n">batch_size</span><span class="p">,</span> <span class="n">seq_len</span>
            <span class="p">)</span>

            <span class="c1"># Flash Attention</span>
            <span class="n">flash_time</span><span class="p">,</span> <span class="n">flash_mem</span> <span class="o">=</span> <span class="n">benchmark_flash_attention</span><span class="p">(</span>
                <span class="n">batch_size</span><span class="p">,</span> <span class="n">seq_len</span>
            <span class="p">)</span>

            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;seq_len&#39;</span><span class="p">:</span> <span class="n">seq_len</span><span class="p">,</span>
                <span class="s1">&#39;batch_size&#39;</span><span class="p">:</span> <span class="n">batch_size</span><span class="p">,</span>
                <span class="s1">&#39;speedup&#39;</span><span class="p">:</span> <span class="n">std_time</span> <span class="o">/</span> <span class="n">flash_time</span><span class="p">,</span>
                <span class="s1">&#39;memory_saving&#39;</span><span class="p">:</span> <span class="n">std_mem</span> <span class="o">/</span> <span class="n">flash_mem</span>
            <span class="p">})</span>

    <span class="k">return</span> <span class="n">results</span>
</code></pre></div>

<p><strong>注意力下采样策略</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">AttentionDownsampling</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">downsample_ratio</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">downsample_ratio</span>

    <span class="k">def</span> <span class="nf">compute_attention</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># 1. 对 K,V 进行下采样</span>
        <span class="n">k_downsampled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">)</span>
        <span class="n">v_downsampled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">)</span>

        <span class="c1"># 2. 计算稀疏注意力</span>
        <span class="n">attn_scores</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">k_downsampled</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">attn_weights</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">attn_scores</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d_k</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># 3. 加权聚合</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">attn_weights</span><span class="p">,</span> <span class="n">v_downsampled</span><span class="p">)</span>

        <span class="c1"># 4. 上采样恢复</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upsample</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span>
</code></pre></div>

<h3 id="424">4.2.4 分块策略与滑动窗口</h3>
<p><strong>分块处理框架</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">ChunkedProcessing</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mi">256</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">=</span> <span class="n">chunk_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span>

    <span class="k">def</span> <span class="nf">process_long_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_chunks</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">chunk_outputs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># 维护跨块状态</span>
        <span class="n">cross_chunk_state</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunks</span><span class="p">):</span>
            <span class="c1"># 添加上下文</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">:]</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="n">context</span> <span class="o">+</span> <span class="n">chunk</span>

            <span class="c1"># 处理当前块</span>
            <span class="n">output</span><span class="p">,</span> <span class="n">new_state</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">process_with_state</span><span class="p">(</span>
                <span class="n">chunk</span><span class="p">,</span> <span class="n">cross_chunk_state</span>
            <span class="p">)</span>

            <span class="c1"># 更新状态</span>
            <span class="n">cross_chunk_state</span> <span class="o">=</span> <span class="n">new_state</span>

            <span class="c1"># 去除重叠部分</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">:]</span>

            <span class="n">chunk_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_outputs</span><span class="p">(</span><span class="n">chunk_outputs</span><span class="p">)</span>
</code></pre></div>

<p><strong>滑动窗口注意力</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">sliding_window_attention</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    生成滑动窗口注意力掩码</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">seq_len</span><span class="p">):</span>
        <span class="c1"># 局部窗口</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># 跨步连接（用于长距离依赖）</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">stride</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">window_size</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">mask</span>
</code></pre></div>

<p><strong>层次化处理策略</strong></p>
<div class="codehilite"><pre><span></span><code>文档级别处理：
┌──────────────────────────────────┐
│          完整文档 (32K)          │
└──────────────────────────────────┘
                ↓
┌─────────┬─────────┬─────────┬─────────┐
│ 段落1   │ 段落2   │ 段落3   │ 段落4   │
│ (8K)    │ (8K)    │ (8K)    │ (8K)    │
└─────────┴─────────┴─────────┴─────────┘
                ↓
┌───┬───┬───┬───┬───┬───┬───┬───┐
│句1│句2│...│句n│句1│句2│...│句m│  细粒度处理
└───┴───┴───┴───┴───┴───┴───┴───┘
</code></pre></div>

<p><strong>实验评估协议</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">evaluate_long_context_methods</span><span class="p">():</span>
    <span class="n">test_suite</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;retrieval&#39;</span><span class="p">:</span> <span class="n">test_needle_in_haystack</span><span class="p">,</span>  <span class="c1"># 长文检索</span>
        <span class="s1">&#39;summary&#39;</span><span class="p">:</span> <span class="n">test_summarization</span><span class="p">,</span>          <span class="c1"># 摘要生成</span>
        <span class="s1">&#39;qa&#39;</span><span class="p">:</span> <span class="n">test_multi_hop_qa</span><span class="p">,</span>               <span class="c1"># 多跳问答</span>
        <span class="s1">&#39;coherence&#39;</span><span class="p">:</span> <span class="n">test_long_form_generation</span>  <span class="c1"># 长文生成连贯性</span>
    <span class="p">}</span>

    <span class="n">methods</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;baseline&#39;</span><span class="p">:</span> <span class="n">StandardAttention</span><span class="p">(),</span>
        <span class="s1">&#39;chunked&#39;</span><span class="p">:</span> <span class="n">ChunkedProcessing</span><span class="p">(),</span>
        <span class="s1">&#39;sliding&#39;</span><span class="p">:</span> <span class="n">SlidingWindowAttention</span><span class="p">(),</span>
        <span class="s1">&#39;sparse&#39;</span><span class="p">:</span> <span class="n">SparseAttention</span><span class="p">(),</span>
        <span class="s1">&#39;hierarchical&#39;</span><span class="p">:</span> <span class="n">HierarchicalProcessing</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">methods</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">results</span><span class="p">[</span><span class="n">method_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">task_name</span><span class="p">,</span> <span class="n">task_fn</span> <span class="ow">in</span> <span class="n">test_suite</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">task_fn</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">method_name</span><span class="p">][</span><span class="n">task_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span>

    <span class="k">return</span> <span class="n">results</span>
</code></pre></div>

<p><strong>内存优化技巧</strong></p>
<ol>
<li><strong>梯度检查点（Gradient Checkpointing）</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># 用计算换内存</span>
<span class="k">def</span> <span class="nf">forward_with_checkpointing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># 不保存中间激活值，反向传播时重新计算</span>
    <span class="k">return</span> <span class="n">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformer_block</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div>

<ol start="2">
<li><strong>混合精度训练</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># FP16/BF16 减少内存占用</span>
<span class="k">with</span> <span class="n">autocast</span><span class="p">():</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
</code></pre></div>

<ol start="3">
<li><strong>激活值重计算</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># 选择性保存关键层的激活值</span>
<span class="n">critical_layers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">24</span><span class="p">]</span>  <span class="c1"># 仅保存这些层</span>
</code></pre></div>

<h2 id="43-cot">4.3 思维链（CoT）训练策略</h2>
<p>思维链（Chain-of-Thought）是提升 LLM 推理能力的关键技术。通过训练模型生成中间推理步骤，CoT 显著改善了复杂推理任务的性能。本节探讨如何设计实验来构建高质量的 CoT 数据集、优化训练策略，以及解决 CoT 训练中的常见问题。</p>
<h3 id="431-cot">4.3.1 CoT 数据的构造方法</h3>
<p><strong>CoT 数据的核心要素</strong></p>
<p>高质量的 CoT 数据需要满足：</p>
<ol>
<li><strong>步骤完整性</strong>：覆盖从问题到答案的所有推理步骤</li>
<li><strong>逻辑连贯性</strong>：步骤间有清晰的因果关系</li>
<li><strong>粒度适中</strong>：既不过于冗长，也不跳跃太大</li>
<li><strong>错误可追溯</strong>：便于定位推理错误的位置</li>
</ol>
<p><strong>自动化 CoT 生成策略</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">CoTGenerator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_model</span><span class="p">,</span> <span class="n">verifier_model</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span> <span class="o">=</span> <span class="n">base_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verifier</span> <span class="o">=</span> <span class="n">verifier_model</span>

    <span class="k">def</span> <span class="nf">generate_cot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question</span><span class="p">,</span> <span class="n">answer</span><span class="p">):</span>
        <span class="c1"># 1. 零样本 CoT 生成</span>
        <span class="n">prompt</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Question: </span><span class="si">{</span><span class="n">question</span><span class="si">}</span><span class="se">\n</span><span class="s2">Let&#39;s think step by step:&quot;</span>
        <span class="n">reasoning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>

        <span class="c1"># 2. 验证推理链</span>
        <span class="n">validity_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verifier</span><span class="o">.</span><span class="n">check_reasoning</span><span class="p">(</span>
            <span class="n">question</span><span class="p">,</span> <span class="n">reasoning</span><span class="p">,</span> <span class="n">answer</span>
        <span class="p">)</span>

        <span class="c1"># 3. 迭代优化</span>
        <span class="k">while</span> <span class="n">validity_score</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="c1"># 添加引导信息</span>
            <span class="n">feedback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verifier</span><span class="o">.</span><span class="n">get_feedback</span><span class="p">(</span><span class="n">reasoning</span><span class="p">)</span>
            <span class="n">prompt_with_feedback</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prompt</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">feedback</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">reasoning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">prompt_with_feedback</span><span class="p">)</span>
            <span class="n">validity_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verifier</span><span class="o">.</span><span class="n">check_reasoning</span><span class="p">(</span>
                <span class="n">question</span><span class="p">,</span> <span class="n">reasoning</span><span class="p">,</span> <span class="n">answer</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">reasoning</span>
</code></pre></div>

<p><strong>多样化 CoT 采样</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">diverse_cot_sampling</span><span class="p">(</span><span class="n">question</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    生成多样化的推理路径</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cot_samples</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># 温度采样</span>
    <span class="k">for</span> <span class="n">temp</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">]:</span>
        <span class="n">cot</span> <span class="o">=</span> <span class="n">generate_with_temperature</span><span class="p">(</span><span class="n">question</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
        <span class="n">cot_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cot</span><span class="p">)</span>

    <span class="c1"># 提示变体</span>
    <span class="n">prompt_templates</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;Let&#39;s solve this step by step:&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Breaking this down:&quot;</span><span class="p">,</span>
        <span class="s2">&quot;First, let me understand the problem:&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Let&#39;s approach this systematically:&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Working through this carefully:&quot;</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="n">prompt_templates</span><span class="p">:</span>
        <span class="n">cot</span> <span class="o">=</span> <span class="n">generate_with_prompt</span><span class="p">(</span><span class="n">question</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
        <span class="n">cot_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cot</span><span class="p">)</span>

    <span class="c1"># 去重和质量筛选</span>
    <span class="n">unique_cots</span> <span class="o">=</span> <span class="n">deduplicate_reasoning_paths</span><span class="p">(</span><span class="n">cot_samples</span><span class="p">)</span>
    <span class="n">high_quality_cots</span> <span class="o">=</span> <span class="n">filter_by_quality</span><span class="p">(</span><span class="n">unique_cots</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">high_quality_cots</span>
</code></pre></div>

<p><strong>领域特定 CoT 模板</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 数学推理模板</span>
<span class="n">MATH_COT_TEMPLATE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">1. 理解问题：</span><span class="si">{problem_understanding}</span>
<span class="s2">2. 识别已知条件：</span><span class="si">{given_conditions}</span>
<span class="s2">3. 确定求解目标：</span><span class="si">{target}</span>
<span class="s2">4. 选择解法：</span><span class="si">{method_selection}</span>
<span class="s2">5. 执行计算：</span><span class="si">{calculation_steps}</span>
<span class="s2">6. 验证答案：</span><span class="si">{verification}</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="c1"># 逻辑推理模板</span>
<span class="n">LOGIC_COT_TEMPLATE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">1. 前提条件：</span><span class="si">{premises}</span>
<span class="s2">2. 推理规则：</span><span class="si">{rules}</span>
<span class="s2">3. 推导过程：</span><span class="si">{derivation}</span>
<span class="s2">4. 结论：</span><span class="si">{conclusion}</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="c1"># 代码推理模板</span>
<span class="n">CODE_COT_TEMPLATE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">1. 需求分析：</span><span class="si">{requirements}</span>
<span class="s2">2. 算法设计：</span><span class="si">{algorithm}</span>
<span class="s2">3. 复杂度分析：</span><span class="si">{complexity}</span>
<span class="s2">4. 边界条件：</span><span class="si">{edge_cases}</span>
<span class="s2">5. 实现：</span><span class="si">{implementation}</span>
<span class="s2">&quot;&quot;&quot;</span>
</code></pre></div>

<h3 id="432">4.3.2 推理步骤的质量控制</h3>
<p><strong>步骤粒度控制</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">optimize_step_granularity</span><span class="p">(</span><span class="n">cot_chain</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    优化推理步骤的粒度</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">optimized_chain</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cot_chain</span><span class="p">):</span>
        <span class="c1"># 检测过于复杂的步骤</span>
        <span class="k">if</span> <span class="n">is_complex_step</span><span class="p">(</span><span class="n">step</span><span class="p">):</span>
            <span class="c1"># 分解为子步骤</span>
            <span class="n">sub_steps</span> <span class="o">=</span> <span class="n">decompose_step</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="n">optimized_chain</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sub_steps</span><span class="p">)</span>

        <span class="c1"># 检测冗余步骤</span>
        <span class="k">elif</span> <span class="n">is_redundant_step</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">optimized_chain</span><span class="p">):</span>
            <span class="k">continue</span>  <span class="c1"># 跳过冗余</span>

        <span class="c1"># 合并过于细碎的步骤</span>
        <span class="k">elif</span> <span class="n">is_trivial_step</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># 与前一步合并</span>
            <span class="n">optimized_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge_steps</span><span class="p">(</span><span class="n">optimized_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">step</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">optimized_chain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">optimized_chain</span>
</code></pre></div>

<p><strong>逻辑一致性检查</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">LogicConsistencyChecker</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_logic_rules</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">check_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cot_chain</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        检查推理链的逻辑一致性</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">issues</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># 1. 前后矛盾检测</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cot_chain</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contradicts</span><span class="p">(</span><span class="n">cot_chain</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cot_chain</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">issues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> contradicts step </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># 2. 循环推理检测</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_circular_reasoning</span><span class="p">(</span><span class="n">cot_chain</span><span class="p">):</span>
            <span class="n">issues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Circular reasoning detected&quot;</span><span class="p">)</span>

        <span class="c1"># 3. 跳跃推理检测</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cot_chain</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_transition</span><span class="p">(</span><span class="n">cot_chain</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cot_chain</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">issues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid transition from step </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># 4. 前提完备性检查</span>
        <span class="n">missing_premises</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_premises</span><span class="p">(</span><span class="n">cot_chain</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">missing_premises</span><span class="p">:</span>
            <span class="n">issues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing premises: </span><span class="si">{</span><span class="n">missing_premises</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">issues</span>
</code></pre></div>

<p><strong>数值准确性验证</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">verify_numerical_accuracy</span><span class="p">(</span><span class="n">cot_chain</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    验证推理链中的数值计算</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numerical_errors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">cot_chain</span><span class="p">:</span>
        <span class="c1"># 提取数学表达式</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="n">extract_math_expressions</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># 符号计算验证</span>
                <span class="n">symbolic_result</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

                <span class="c1"># 数值计算验证</span>
                <span class="n">numerical_result</span> <span class="o">=</span> <span class="n">eval_safely</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

                <span class="c1"># 检查一致性</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">symbolic_result</span><span class="p">,</span> <span class="n">numerical_result</span><span class="p">,</span> <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">):</span>
                    <span class="n">numerical_errors</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="n">step</span><span class="p">,</span>
                        <span class="s1">&#39;expression&#39;</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span>
                        <span class="s1">&#39;symbolic&#39;</span><span class="p">:</span> <span class="n">symbolic_result</span><span class="p">,</span>
                        <span class="s1">&#39;numerical&#39;</span><span class="p">:</span> <span class="n">numerical_result</span>
                    <span class="p">})</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">numerical_errors</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="n">step</span><span class="p">,</span>
                    <span class="s1">&#39;expression&#39;</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span>
                    <span class="s1">&#39;error&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="p">})</span>

    <span class="k">return</span> <span class="n">numerical_errors</span>
</code></pre></div>

<h3 id="433">4.3.3 自洽性训练</h3>
<p><strong>Self-Consistency 实现</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">SelfConsistencyTraining</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">num_paths</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_paths</span> <span class="o">=</span> <span class="n">num_paths</span>

    <span class="k">def</span> <span class="nf">train_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question</span><span class="p">,</span> <span class="n">true_answer</span><span class="p">):</span>
        <span class="c1"># 1. 生成多条推理路径</span>
        <span class="n">reasoning_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_paths</span><span class="p">):</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">generate_cot</span><span class="p">(</span><span class="n">question</span><span class="p">)</span>
            <span class="n">reasoning_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># 2. 投票得出答案</span>
        <span class="n">answers</span> <span class="o">=</span> <span class="p">[</span><span class="n">extract_answer</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">reasoning_paths</span><span class="p">]</span>
        <span class="n">majority_answer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_vote</span><span class="p">(</span><span class="n">answers</span><span class="p">)</span>

        <span class="c1"># 3. 选择一致的路径作为正例</span>
        <span class="n">consistent_paths</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">path</span> <span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">ans</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">reasoning_paths</span><span class="p">,</span> <span class="n">answers</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ans</span> <span class="o">==</span> <span class="n">majority_answer</span>
        <span class="p">]</span>

        <span class="c1"># 4. 构造训练样本</span>
        <span class="k">if</span> <span class="n">majority_answer</span> <span class="o">==</span> <span class="n">true_answer</span><span class="p">:</span>
            <span class="c1"># 正确答案：所有一致路径都是正例</span>
            <span class="n">positive_samples</span> <span class="o">=</span> <span class="n">consistent_paths</span>
            <span class="n">negative_samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 错误答案：需要生成修正路径</span>
            <span class="n">positive_samples</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">generate_correction</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">true_answer</span><span class="p">)]</span>
            <span class="n">negative_samples</span> <span class="o">=</span> <span class="n">consistent_paths</span>

        <span class="c1"># 5. 对比学习</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contrastive_loss</span><span class="p">(</span>
            <span class="n">positive_samples</span><span class="p">,</span> <span class="n">negative_samples</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">loss</span>
</code></pre></div>

<p><strong>路径多样性奖励</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">diversity_reward</span><span class="p">(</span><span class="n">reasoning_paths</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算推理路径的多样性奖励</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reasoning_paths</span><span class="p">)</span>
    <span class="n">diversity_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="c1"># 计算路径相似度</span>
            <span class="n">similarity</span> <span class="o">=</span> <span class="n">path_similarity</span><span class="p">(</span>
                <span class="n">reasoning_paths</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
                <span class="n">reasoning_paths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">diversity_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">similarity</span>
            <span class="n">diversity_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">diversity_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

    <span class="c1"># 多样性得分：平均两两差异</span>
    <span class="n">diversity_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diversity_matrix</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">diversity_score</span>

<span class="k">def</span> <span class="nf">path_similarity</span><span class="p">(</span><span class="n">path1</span><span class="p">,</span> <span class="n">path2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算两条推理路径的相似度</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 1. 结构相似度（步骤数量、顺序）</span>
    <span class="n">struct_sim</span> <span class="o">=</span> <span class="n">structural_similarity</span><span class="p">(</span><span class="n">path1</span><span class="p">,</span> <span class="n">path2</span><span class="p">)</span>

    <span class="c1"># 2. 语义相似度（内容相似性）</span>
    <span class="n">semantic_sim</span> <span class="o">=</span> <span class="n">semantic_similarity</span><span class="p">(</span><span class="n">path1</span><span class="p">,</span> <span class="n">path2</span><span class="p">)</span>

    <span class="c1"># 3. 方法相似度（使用的推理方法）</span>
    <span class="n">method_sim</span> <span class="o">=</span> <span class="n">method_similarity</span><span class="p">(</span><span class="n">path1</span><span class="p">,</span> <span class="n">path2</span><span class="p">)</span>

    <span class="k">return</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">struct_sim</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">semantic_sim</span> <span class="o">+</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">method_sim</span>
</code></pre></div>

<h3 id="434">4.3.4 错误传播与纠正机制</h3>
<p><strong>错误传播分析</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">ErrorPropagationAnalyzer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_types</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;calculation&#39;</span><span class="p">:</span> <span class="s1">&#39;计算错误&#39;</span><span class="p">,</span>
            <span class="s1">&#39;logic&#39;</span><span class="p">:</span> <span class="s1">&#39;逻辑错误&#39;</span><span class="p">,</span>
            <span class="s1">&#39;assumption&#39;</span><span class="p">:</span> <span class="s1">&#39;假设错误&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interpretation&#39;</span><span class="p">:</span> <span class="s1">&#39;理解错误&#39;</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">trace_error_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cot_chain</span><span class="p">,</span> <span class="n">final_error</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        追踪错误在推理链中的传播</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">error_trace</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># 反向追踪</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cot_chain</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">cot_chain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># 检测该步骤是否包含错误</span>
            <span class="n">step_errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detect_step_errors</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">step_errors</span><span class="p">:</span>
                <span class="n">error_trace</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;step_index&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
                    <span class="s1">&#39;step_content&#39;</span><span class="p">:</span> <span class="n">step</span><span class="p">,</span>
                    <span class="s1">&#39;errors&#39;</span><span class="p">:</span> <span class="n">step_errors</span><span class="p">,</span>
                    <span class="s1">&#39;impact&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">assess_impact</span><span class="p">(</span><span class="n">step_errors</span><span class="p">,</span> <span class="n">final_error</span><span class="p">)</span>
                <span class="p">})</span>

                <span class="c1"># 判断是否为根本原因</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_root_cause</span><span class="p">(</span><span class="n">step_errors</span><span class="p">,</span> <span class="n">cot_chain</span><span class="p">[:</span><span class="n">i</span><span class="p">]):</span>
                    <span class="n">error_trace</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;is_root_cause&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">error_trace</span>
</code></pre></div>

<p><strong>自动纠错机制</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">AutoCorrector</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">verifier</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verifier</span> <span class="o">=</span> <span class="n">verifier</span>

    <span class="k">def</span> <span class="nf">correct_reasoning_chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cot_chain</span><span class="p">,</span> <span class="n">question</span><span class="p">,</span> <span class="n">expected_answer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        自动纠正推理链中的错误</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">corrected_chain</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">error_detected</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cot_chain</span><span class="p">):</span>
            <span class="c1"># 验证当前步骤</span>
            <span class="n">step_valid</span><span class="p">,</span> <span class="n">error_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verifier</span><span class="o">.</span><span class="n">verify_step</span><span class="p">(</span>
                <span class="n">step</span><span class="p">,</span> 
                <span class="n">context</span><span class="o">=</span><span class="n">corrected_chain</span><span class="p">,</span>
                <span class="n">question</span><span class="o">=</span><span class="n">question</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">step_valid</span><span class="p">:</span>
                <span class="n">corrected_chain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">error_detected</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># 生成修正步骤</span>
                <span class="n">correction_prompt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_correction_prompt</span><span class="p">(</span>
                    <span class="n">step</span><span class="p">,</span> <span class="n">error_info</span><span class="p">,</span> <span class="n">corrected_chain</span><span class="p">,</span> <span class="n">question</span>
                <span class="p">)</span>

                <span class="n">corrected_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">correction_prompt</span><span class="p">)</span>

                <span class="c1"># 验证修正</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verifier</span><span class="o">.</span><span class="n">verify_step</span><span class="p">(</span><span class="n">corrected_step</span><span class="p">,</span> <span class="n">corrected_chain</span><span class="p">,</span> <span class="n">question</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">corrected_chain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corrected_step</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># 如果修正失败，重新生成整个后续链</span>
                    <span class="n">remaining_chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regenerate_from_step</span><span class="p">(</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">corrected_chain</span><span class="p">,</span> <span class="n">question</span><span class="p">,</span> <span class="n">expected_answer</span>
                    <span class="p">)</span>
                    <span class="n">corrected_chain</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">remaining_chain</span><span class="p">)</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">corrected_chain</span><span class="p">,</span> <span class="n">error_detected</span>
</code></pre></div>

<p><strong>错误模式学习</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">ErrorPatternLearning</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_patterns</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">learn_from_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_examples</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        从错误案例中学习模式</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">error_examples</span><span class="p">:</span>
            <span class="c1"># 提取错误特征</span>
            <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_error_features</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>

            <span class="c1"># 聚类相似错误</span>
            <span class="n">cluster_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_error</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">error_patterns</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;features&#39;</span><span class="p">:</span> <span class="n">features</span><span class="p">,</span>
                <span class="s1">&#39;correction&#39;</span><span class="p">:</span> <span class="n">example</span><span class="p">[</span><span class="s1">&#39;correction&#39;</span><span class="p">],</span>
                <span class="s1">&#39;explanation&#39;</span><span class="p">:</span> <span class="n">example</span><span class="p">[</span><span class="s1">&#39;explanation&#39;</span><span class="p">]</span>
            <span class="p">})</span>

    <span class="k">def</span> <span class="nf">predict_error_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        预测步骤出错的可能性</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_step_features</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="n">max_similarity</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">most_likely_error</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">cluster_id</span><span class="p">,</span> <span class="n">patterns</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_patterns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
                <span class="n">similarity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_similarity</span><span class="p">(</span>
                    <span class="n">features</span><span class="p">,</span> <span class="n">pattern</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">similarity</span> <span class="o">&gt;</span> <span class="n">max_similarity</span><span class="p">:</span>
                    <span class="n">max_similarity</span> <span class="o">=</span> <span class="n">similarity</span>
                    <span class="n">most_likely_error</span> <span class="o">=</span> <span class="n">pattern</span>

        <span class="k">return</span> <span class="n">max_similarity</span><span class="p">,</span> <span class="n">most_likely_error</span>
</code></pre></div>

<h2 id="44">4.4 领域适应与持续学习</h2>
<h3 id="441">4.4.1 领域数据的选择与配比</h3>
<h3 id="442">4.4.2 灾难性遗忘的缓解</h3>
<h3 id="443">4.4.3 增量学习策略</h3>
<h3 id="444">4.4.4 知识蒸馏与正则化</h3>
<h2 id="45">4.5 幻觉检测与缓解</h2>
<h3 id="451">4.5.1 幻觉的分类与成因</h3>
<h3 id="452">4.5.2 检测方法与评估指标</h3>
<h3 id="453">4.5.3 训练时的缓解策略</h3>
<h3 id="454">4.5.4 推理时的干预技术</h3>
<h2 id="_3">本章小结</h2>
<h2 id="_4">练习题</h2>
<h2 id="gotchas">常见陷阱与错误（Gotchas）</h2>
            </article>
            
            <nav class="page-nav"><a href="chapter3.html" class="nav-link prev">← 第三章：数据工程</a><a href="chapter5.html" class="nav-link next">第五章：多模态任务实验设计 →</a></nav>
        </main>
    </div>
</body>
</html>